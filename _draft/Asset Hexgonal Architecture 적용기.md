# Asset Hexgonal Architecture 적용기

DSP의 스프링 프로젝트에서 일반적으로 MVC 패턴을 사용하여 프로젝트가 개발되고 있다. MVC는 해당 글에선 스프링 MVC 구조에 의해서 일반적으로 사용되는 Controller-Service-Repository 레이어로 구분하여 사용212121₩하는 것을 의미한다.

해당 글에선 일반적으로 사용되면 스프링 MVC 구조에서 벗어나 육각 설계<sup>Hexagonal Architecture</sup>의 설명과 이를 도입하게된 배경과 소개한다.

# 기존 MVC 구조의 한계

## 뷰에서 여러 데이터 엔티티와 연관되면 발생하는 문제

- 여러 데이터 엔티티가 조합되는 경우 수직적 구성이든, 수평적 구성이든 그 구분이 모호해진다.

스프링 MVC에선 Controller-Service-Repository로 레이어를 나눈 구조지만 각 레이어로 그 역할을 분리하는데, 보통 데이터베이스의 테이블울 가준으로 생성한 데이터 엔티티를 기준으로 패키지를 구성하게 된다.

```
src.main.java.project
  > a
    > controller
    > serivce
    > repository
  > b
    > controller
    > serivce
    > repository
```

[완전히 데이터베이스 엔티티를 기준으로 묶여진 패키지 구조]

데이터베이스 엔티티를 기준으로 MVC를 모두 묶는 경우 다른 데이터 엔티티끼리 레퍼런스를 하기 어렵고 여러 엔티티를 하나의 로직에서 사용하기 어렵다.  
때문에 현재 DSP의 프로젝트의 패키지 구조는 일반적으로 아래의 두가지의 모습을 가지고 있다.

```
src.main.java.project
  > controller
    > a
    > b
  > service
    > a
      > repository
    > b
      > repository
```

[서비스에 데이터베이스가 종속적인 경우]

```
src.main.java.project
  > controller
    > a
    > b
  > repository
    > a
    > b
  > service
    > a
    > b
```

[서비스와 데이터베이스가 분리된 경우]

각 데이터 엔티티 간의 사용에 대해서 재사용을 좀 더 허용하는 구조로 되어있다. 하지만 여전히 문제는 존재한다. 로직에서 다른 데이터 엔티티를 함께 사용(CRUD)할 수 있지만, MVC의 뷰의 영역에서 여러 데이터 엔티티가 조합된 리스폰스를 요구하는 경우 문제가 발생한다.

다른 조합 없이 데이터 엔티티가 뷰의 영역까지 그대로 이어지는 경우엔 데이터 엔티티를 기준으로 나눠진 컨트롤러에서 리스폰스를 내려주면 된다.

```java
@RestController
@RequestMapping("/a")
public class AController {
    ...
    @GatMapping("/{id}")
    public AResponse getA(@PathVariable Long id) {
        final AEntity entity = aService.get(id);
        final AResponse response = responseConverter.convert(entity);
        return response;
    }
    ...
```

하지만 여러개의 데이터 엔티티가 조합된 리스폰스라면 그 구분을 어떻게 해야될지가 문제가 된다. 일반적으로 이런 상황에서 아래의 두가지 방법을 선택하게 되는데, 그에 따라 각각 문제점이 존재한다.

1. ABController를 만들고 AService와 BService를 ABController에서 직접 사용.  
   -> 조합된 결과물을 기준으로 컨트롤러를 생성하게 되는데, 두개의 서비스를 조합해서 사용하는 것 자체가 로직에 영향을 끼칠 수 있기 때문에 문제가 될 수 있다.
2. AContoller에서 AService를 사용하고, ASerivce에서 BService 혹은 BRepository를 사용.
   -> A에서 B를 접근하고 B에서 A를 접근하는 등 두 데이터 엔티티 간의 관계가 복잡해 질 수 있다. 그리고 두 엔티티간의 관계를 명확하게 하지 않으면 순환참조가 발생할 수 있다.

## 프로젝트가 JPA에 의존적이게 되는 문제

- JPA에 너무 의존적이다.
- 각 엔티티 간의 관계가 복잡해진다.

JPA는 개발자가 반복적으로 구현해야하는 CRUD의 쿼리들을 따로 작성할 필요없이 사용할 수 있도록 도와주어 생산성을 높힐 수 있도록 도와준다.

JPA가 ORM을 구현하기 위해서 제공하는 기능들이 존재하기 때문에 JPA를 사용하기 위해 따로 공부가 필요하지만 JPA가 많은 프로젝트에서 사용화되어 사용되고 있기 때문에 백엔드 개발자들에게 기본적인 스펙으로 사용되고 있다. 문제는 이렇게 보편적인 기능으로 사용되기 시작하면서 비즈니스 로직을 담당하는 서비스 레이어와 영속성을 담당하는 리포지토리 레이어간의 경계가 모호하게 개발되는 경우가 많아진다는 것이다.

JPA에선 데이터베이스의 테이블과 오브젝트가 맵핑되어 사용되며, 해당 오브젝트는 JPA 엔티티로써 JPA 영속성 컨텍스트 안에서 관리된다. 때문에 JPA 리포지토리로 부터 반환된 오브젝트를 별도의 과정 없이 직접 사용하는 경우 Persistence Context에서 관리되는 JPA 엔티티 클래스를 서비스 레이어에서 직접 사용하게 된다. 이 경우 서비스 레이어에서 JPA 엔티티의 기능들을 로직인 것 마냥 사용하게 되는 경우가 발생한다.

한가지 예로 JPA 엔티티는 더티 체크를 지원하게 되는데, 영속성 컨텍스트에서 관리되는 엔티티의 변경점이 발생하는 경우 별도의 `save()`와 같은 메서드 호출이 없다고 하더라도 Hibernate에선 트랜젝션 커밋 시점에 이를 저장하게 된다. 별도의 메서드 호출 없이 저장되기 때문에 편리하다고 생각할 수도 있지만, 이는 서비스 레이어의 기능도 아니고 익숙하지 않은 코드에서 이러한 기능을 사용하게 되는 경우 코드에서의 엔티티가 영속성 컨텍스트에서 관리되는 엔티티인지, 실제 반영은 언제 되는지 등의 파악이 어렵다.

##

# Hexagonal Architecture 개요

헥사고날의 주요 특징은 계층 설계와 달리, 각 구성요소들 사이의 의존성이 도메인 영역을 가리킨다는 것이다.

![hexagonal-architecture-0](https://user-images.githubusercontent.com/18159012/136333083-7145b6de-bbf6-49a8-a016-2a5ec45949e2.jpg)

육각 설계는 프로젝트의 코어가 되는 유즈 케이스<sup>Use Case</sup>와 도메인을 담당하고 도메인 외부의 각 컴포넌트는 웹 리퀘스트와 리스폰스, DB 커넥션, Kafka와 같은 메세지 어댑터들을 포트를 통해서 접근하도록 한다.

## 도메인 엔티티

도메인 엔티티들은 비즈니즈 로직에서의 상태와 동작을 모두 포함하는 오브젝트다.

도메인 엔티티는 외부 종속성이 없다. 때문에 다른 레이어의 변경이 있더라도 비즈니스 로직에 영향을 주지 않는다.

## 유즈 케이스<sup>Use Case</sup>

일반적인 Use Case는 사용자가 서비스를 추상적인 목표를 의미한다.

육각 설계에서의 Use Case는 특정 사용 사례와 관련된 모든 것을 처리하는 클래스를 의미한다. 예를 들어, 은행 어플리케이션에서 "한 계좌에서 다른 계좌로 송금"을 사용하는 경우, 사용자가 송금할 수 있는 고유한 API를 사용하여 SendMoneyUseCase 클래스를 만든다. 해당 클래스에선 도메인 엔티티에서 구현할 수없는 모든 비즈니스 로직과 유효성 검사<sup>Validation</sup>를 포함한다.

도메인 엔티티와 마찬가지로, Use Case 클래스는 외부 구성 요소에 종속되지 않는다. 육각 설계 외부에서 무언가를 필요로 할 떄, 포트를 통해서 전달한다.

## 포트

육각 설계의 도메인과 Use Case (이하 서비스)는 어플리케이션의 핵심인 육각형 안에 존재한다. 외부와의 모든 통신은 '포트'를 통해서 이루어진다.

포트는 육각형에 접근하는 방향에 따라 입력<sup>Input</sup> / 출력<sup>Output</sup> 포트로 구분된다.

입출력 포트를 구현하면 비즈니즈 로직에 데이터가 들어오고 나가는 위치가 뚜렷해지기 때문에 설계에 대해서 쉽게 추론을 할 수 있게 된다.

## 어댑터

어댑터는 육각 설계의 외부 계층을 형성한다. 코어를 담당하진 않지만 코어와 상호작용한다.

입력 어댑터는 입력 포트를 호출하여 작업을 수행한다. 예를 들어 사용자가 브라우저에서 버튼을 클릭하면 웹 어댑터가 특정 입력 포트를 호출하여 버튼에 해당하는 Use Case를 수행한다.

출력 어댑터는 Use Case에 의해 호출되며, 데이터를 제공한다. 출력 어댑터는 Use Case에 의해 독점되어 사용된다.

어댑터를 사용하여 어플리케이션의 특정 레이어 간의 데이터 교환을 쉽게 할 수 있다. 새로운 데이터베이스를 사용하는 경우 어댑터 인터페이스를 구현하여 새로운 persistence 어댑터를 추가하는 식으로 확장할 수 있다.

> ref : https://reflectoring.io/spring-hexagonal/

# Asset Hexagonal Trouble Shooting

- port 구성의 문제 (adapter 패턴...)
  - \> 포트를 사용하지않고 일단 adapter를 바로 사용하자
- 패키지 구조의 문제
  - \> Persistence 등 port 기능에 따라 구분
- 도메인(기능)별로 서비스와 도메인 엔티티를 만들어야 되나?
  - \> Sync Input
- 다른 엔티티를 저장해야 하는 경우 어느 레이어에서 의존성을 가져야 할까 (service or adapter)
  - \> Serivce가 UseCase로 사용되고 해당 레이어에서 여러 엔티티에 대한 의존성을 가지는 건 괜찮음

<br>
<br>

---

---

<br>
<br>

- Creative hash를 통한 재사용
  - 새로운 컬럼을 두고 새로운 hash일 때, 새로운 컬럼(플래그)을 변경
- Creative active / deactive
  - RA에서 필요로 하는 creative와 adsvc draft ad 에서 사용하는 creative에 대한 enum 값 혹은 플래그?
- Creative Content id fallback?
  - throw..
  - jpa save <- 이것도 redis 사용할 것 같은데..
- P2 API 목록
  - 관계자 (광고주..) 기준으로 정리
