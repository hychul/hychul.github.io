백엔드를 개발하면서 실제 도메인 엔티티를 포트를 통해 도메인 외부의 경계를 구분하는 헥사고날 아키텍처를 접하고 난 후 그보다 복잡한 게임에서의 올바른 데이터(도메인) 사용 패턴등을 고민하다가 [`Do not use MVC in Unity`](https://youtu.be/er2KzMdUies)라는 영상을 보게 되었다.

# Unity에 MVC를 쓰지 마라

해당 영상에선 MVC가 여전히 안드로이드나 iOS와 같은 클라이언트에선 효율적이지만, 유니티에선 그렇지 않다고 말하고 있다.

Model - Controller - View로 이어지는 패턴은 말 그대로 2D로 구성된 View를 구성하는 컨셉을 가지고 만들어져 있기 때문에 2D 형태의 서비스에선 제대로 동작하지만, 2D가 아닌 카메라, 광원, 게임 오브젝트 등을 가진 Unity와 같은 플랫폼에선 뷰 만으로 MeshRenderer나 Collider 같은 형태를 나타내기 어렵고, 인풋이 있어야 동작하는 MVC와 달리 게임 루프를 통해서 실시간으로 계속적으로 상호작용이 일어나야 하기 때문에 3D에서 인터렉션이 필요한 상황에선 간단하게 MVC를 적용하기 어렵다. 때문에 유니티 뿐만 아니라 언리얼에서도 MVC를 사용하는 것이 불가능에 가깝다고 한다.

엔티티 - 컴포넌트 아키텍처를 기본적으로 적용되어 있는 유니티에선 뷰로 표현되는 레이어가 단순히 ui화면 뿐만 아니라 카메라, 광원, 게임 캐릭터나 환경 등 다양한 방식으로 표현될 수 있다. 안드로이드에선 xml로 구성된 뷰와 ViewGroup과 View로 구성된 ui hierachy가 존재하지만, 유니티에선 뷰를 구성하는 것은 존재하지 않고, Scene 안에 게임 오브젝트와 그 안에 ui 관련 컴포넌트로 구성되기 때문에 다른 2D ui 시스템과 대응 될 만한 구성을 가지지 않는다.

또한 유니티의 기본 ui 컴포넌트는 화면을 구성할 뿐만 아니라 데이터롸 로직을 갖는다. 때문에 유니티는 MVC 패턴을 애초에 구현하지 못한다. 버튼을 예로 들면 버튼에는 버튼과 상호작용할 때 움직임이나 색깔의 변화등에 대한 데이터를 갖고, 버튼 컴포넌트만으로 통해 이런 데이터를 사용하여 버튼 상호작용과 같은 로직을 수행한다.

또한 예제를 보여주며 만약 유니티의 ui를 뷰로 두고서 구현을 해야 한다면, 위에서 말했듯 View 계층구조가 없기 때문에 `GameMenuUI`와 같은 뷰 역할을 하는 컴포넌트를 만들고 그 안에 유니티 UI와 관련된 모든 레퍼런스를 참조하게 하여 사용해야 하기 때문에 MVC를 적용하는 것이 더 안좋은 패턴이라고 말한다. 때문에 MVC를 구현하지 말고 컴포넌트를 만들어 각 게임 오브젝트에서 유니티 UI 레퍼런스를 `GetComponent()` 메서드 등을 사용하여 참조하여 사용하는 것이 더 좋은 방법이라고 소개하고 있다.

# 나는 그렇게 생각하지 않는다

솔직히 제목을 보고 기대를 갖고서 봤기 때문에 내다버린 30분이 되었다. (말이 느려서 2배속으로 봤다...)

MVP 패턴을 처음 2D에 적합하다고 말할떄 까진 뭔가 새로운 방식을 제한하려나 했지만, 안드로이드와 iOS에서의 MVC 적용의 경험을 유니티에 잘못 투영했다고 생각했다.

해당 영상에서 언급한 대로 모바일 UI 환경과 유니티의 환경은 다르게 구성 되어있다. 하지만 유니티가 강제적인 계층 구조를 가지지 않는다고 해서 구현에서도 모든 유니티 UI 컴포넌트를 하나의 뷰 역할을 하는 컴포넌트를 만들어서 모든 레퍼런스를 넣는 것은 유니티에서 MVC 패턴을 구현하는 가장 바보같은 방법이라고 생각한다.

유니티는 UI 구성을 강제하지 않을 뿐이지 유저가 직접 구 계층 구조를 만드는 것을 막지않는다. 심지어 게임 오브젝트들을 계층 구조를 가지기 때문에 계층 구조로 구성하고 싶다면 더 직관적으로 그 구조를 파악할 수 있다.

때문에 메뉴 버튼, 스코어, 시간 그리고 그외의 다양한 UI들로 구성된 화면을 구현할 때 구 역할에 맞는 Controller와 View Group(혹은 계층구조)를 통해 각각의 경계를 오히려 더 자유로우면서도 확실하게 할 수 있다고 생각한다.

또한 3D이기 때문에 View가 아니라는 말은 그냥 단어의 이름 때문에 잘못된 해석을 하는 느낌이었는데, View라는 말은 확실히 화면을 구성하기 위해서 만들어진 MVC 패턴이었기 때문에 '화면'을 나타내는 말로 이름이 붙었지만, 스프링과 같은 백엔드 프레임워크에서도 api 요청에 대한 응답을 얘기할 때도 사용할 만큼 이후에는 범용적으로 쓰이고 있다. 때문에 이름이 갖는 느낌 때문에 좁은 해석 보다는 넓은 해석을 했으면 하는 아쉬움이 컸다.

# 그렇다면 유니티엔 MVC가 좋을까?

계속 어떤 모양이 좋을지 고민인데, MVP<sup>Model View Presenter</sup>패턴이 더 나은 방식이라는 결론에 다다르고 있다.

프레젠터에서 뷰와 모델을 모두 참조하기 때문에 뷰와 모델이 서로를 알수 없게 되고, 프레젠터에서 뷰로 화면의 갱신을 할 때 이벤트등을 사용하여 옵셔널하게 UI가 화면에 노출이 되어있거나, 없을 때에도 모델을 업데이트할 수 있을 것이라는 생각이 들어서 좋은 방향으로 적용을 해보려고 한다.
